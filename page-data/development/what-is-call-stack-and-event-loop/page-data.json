{"componentChunkName":"component---src-templates-blog-post-js","path":"/development/what-is-call-stack-and-event-loop/","result":{"data":{"site":{"siteMetadata":{"title":"samsara-ku blog","author":"[Yunhoe Ku]","siteUrl":"https://samsara-ku.dev","comment":{"disqusShortName":"","utterances":"JaeYeopHan/gatsby-starter-bee"},"sponsor":{"buyMeACoffeeId":"jbee"}}},"markdownRemark":{"id":"f4292127-e211-5d25-866e-f1617490e0f3","excerpt":"😢 해당 포스트는 마이그레이션중인 포스트에요! 추후 업데이트 필요! 웹사이트들을 돌아다니다가 정말 자극적인 문구의 사이트를 보게 되었다!     바로 모든 자바스크립트 개발자가 알아야 하는 33가지 개념이라는 github repo였다! 얼마나 매력적인 제목인가? 마치 저것만 다 읽으면 전문가가 될 것 같은 느낌이다(물론 본인이 많이 노력해야겠지만..)     해당 사이트에 들어가서 제일 먼저 보게 된 내용이, 호출 스택(call stack…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1000px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 94%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAIAAAAf7rriAAAACXBIWXMAAAsTAAALEwEAmpwYAAADOUlEQVQ4y3VSbY/UVBTu/zMEYkz8gKjgBkOiiAaNcdUQwE8ofNh1wWh8CYlCXGYzy+5kcYkhMNNpZ/q6M52+3rbTl9t7b287DfoDPNNdCBo5Obk5PTnPeU7PeQTGGOe8ruuiKFBrURS5rptlGSSrqipfbgIgSWtJkgRBYBiGpmmWZUELSGKMoeClYN/3FUUBzEFrRmuHsWma0AhemA5K+bINNOIVr8AhFhzHgSGhxWQyCcMQ4ul0CrRAbtt2HMfQBUaA6llwYDojy9dTPE9wXFAswKiMUdexRVEEBsAD86KuxmNZ11WggAJYB5De6W9c7qys761+vfPhtZ0LZjAWAt/PcUF4AxuilEIpzMmrBhcsx5SVC8/zgRkyv/bXvth849rO+ctb73zVfbcFh1GKHGw84lXdLJoAIUNXaxaU2CkLhxPPdW1SYE7D24+/+fTu6zd2P766dfZS5/QRuAidQnvISl7QLEBzXe4x5VwurWDpLBmteMoPZC6zROxI31/vXVzf++zW/qW1B6sTpAkhCmyUzmlTMrKv/265riHvUvHV/MnxrP8a6R9z9G3CFmVZEUriHE1CBQJMcniFJA4f6Z7up0+bmlclilJNul8OT+DhSSydYoNXXHOXUADTitd2bOZFyvmhcrjgel4UoixN4SppmtiObyp/JuL7qP8RGnwSPTk31fYJXR42K+Z2ZEDASlqWy8sLcF5JlhVFBQO1wKrHijocTVXDVvSZoruSPKaU1FU9i4ycpC8KToDz4NYApus6HHm72x30H4M0syzJ86RVaA2qsCMTAtqq7Qh8pLtW4SCGqmTqwdRH4d9Pm0XNm0W1fOuFOweR4gYGqPi/wM9smc0KKs5SzcucKJ+F4BAQ3XMG1siLKXy6MWbPyF8El3811d7YP7Uufv6b+sHPo/d+lK9sGm9uDL/tHdyXvS0x6AyC3ijAhB7++BGYUuaESZRk3aF74oZ48bZ65jvprZvD1Tvasev9tZ71hxpvS6grhQ/UsPgPGMxwkYWi3ZF3+tbwy7vahV9G53+Sr27qb9+UNvasHRl1xODe/zJDXMDGKEEJNv1kGiSTIH3uUwSegU+CzA6z5wv/BxNduUe1HW/GAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"js title\"\n        title=\"js title\"\n        src=\"/static/0ed87c16a1a1313a7205465f10b29c22/00d43/js_title.png\"\n        srcset=\"/static/0ed87c16a1a1313a7205465f10b29c22/5a46d/js_title.png 300w,\n/static/0ed87c16a1a1313a7205465f10b29c22/0a47e/js_title.png 600w,\n/static/0ed87c16a1a1313a7205465f10b29c22/00d43/js_title.png 1000w\"\n        sizes=\"(max-width: 1000px) 100vw, 1000px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h3 id=\"-해당-포스트는-마이그레이션중인-포스트에요-추후-업데이트-필요\" style=\"position:relative;\"><a href=\"#-%ED%95%B4%EB%8B%B9-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EB%8A%94-%EB%A7%88%EC%9D%B4%EA%B7%B8%EB%A0%88%EC%9D%B4%EC%85%98%EC%A4%91%EC%9D%B8-%ED%8F%AC%EC%8A%A4%ED%8A%B8%EC%97%90%EC%9A%94-%EC%B6%94%ED%9B%84-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8-%ED%95%84%EC%9A%94\" aria-label=\" 해당 포스트는 마이그레이션중인 포스트에요 추후 업데이트 필요 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>😢 해당 포스트는 마이그레이션중인 포스트에요! 추후 업데이트 필요!</h3>\n<br />\n<p>웹사이트들을 돌아다니다가 정말 자극적인 문구의 사이트를 보게 되었다!    </p>\n<p>바로 <a href=\"https://github.com/yjs03057/33-js-concepts#1-%ED%98%B8%EC%B6%9C-%EC%8A%A4%ED%83%9D\">모든 자바스크립트 개발자가 알아야 하는 33가지 개념</a>이라는 github repo였다! 얼마나 매력적인 제목인가? 마치 저것만 다 읽으면 전문가가 될 것 같은 느낌이다(물론 본인이 많이 노력해야겠지만..)    </p>\n<p>해당 사이트에 들어가서 제일 먼저 보게 된 내용이, <em>호출 스택(call stack)</em>이라고 예전에 자바스크립트의 관련 지식에 대한 이야기를 보다가 본 단어이다.    </p>\n<p>해당 내용을 통하여 들어간 포스트에는 자바스크립트를 처음 접했었을 때 읽었지만, 이해가 잘 가지 않았던 내용들이 꽤나 자세하게 적혀있었다.    </p>\n<p>시간이 흐른 이후에 다시 동일한 내용의 글을 보게 된다면 이해력이 좀 올라가지 않을까 싶어서, 해당 내용에 대해 이해도 할 겸 정리도 해보려고 이번 포스트를 작성하게 되었다!    </p>\n<hr>\n<h2 id=\"우선-들어가기-앞서\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0-%EB%93%A4%EC%96%B4%EA%B0%80%EA%B8%B0-%EC%95%9E%EC%84%9C\" aria-label=\"우선 들어가기 앞서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선 들어가기 앞서</h2>\n<p>나는 해당 분야에 깊은 지식이 없기 때문에, 본 포스트의 글은 원문을 읽고 나름 재해석(?)한 나의 내용이니 올바른 내용이 아닐 수도 있다. 만약 이 글을 읽고 있는 분이 오류를 캐치하거나 그렇다면, 주저없이 댓글로 남겨주시면 좋을 것 같다. <del>바로바로 수정할테니 제발 ㅠㅠ</del></p>\n<p>본 포스트는 <em>Alexander Zlatkov</em>의 <a href=\"https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf\">How JavaScript works: an overview of the engine, the runtime, and the call stack</a>을 중심으로, 최하단의 글들을 참고했다. </p>\n<p>또한 영상 자료로는 <em>Philip Roberts</em>의 <a href=\"https://www.youtube.com/watch?v=8aGhZQkoFbQ\">What the heck is the event loop anyway?</a>을 참고했다. 나와 비슷한 JS초보자 및 영어를 읽기 힘들어하는 사람들에게 좋은 자료가 될 것이다.    </p>\n<hr>\n<h3 id=\"js-engine--js-runtime\" style=\"position:relative;\"><a href=\"#js-engine--js-runtime\" aria-label=\"js engine  js runtime permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JS engine / JS runtime</h3>\n<p>V8이라는 단어를 들어본 적 있는가? 다시 생각해보니 나는 V8이라는 단어를 예전에 JS입문할 때, 중간에 회사를 들어가서 사수분에게 한 번, 이 포스트를 정리하면서 한 번, 총 세 번들은 것 같다.    </p>\n<p>그러나 세 번을 보아도 이게 대충 무엇인지만 알지, 정확하게 무엇을 의미하는지 모르고 있었다. 이 포스트를 쓰면서, 해당 내용이 어느 정도 연관이 있기 때문에 그것에 대하여 정리하는김에 또 JS engine과 관련이 있는 JS Runtime에 대해서도 알아보자.</p>\n<p>우선 JS Engine이다. 위에서 언급한 V8도 JS engine 중 하나이다.    </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAABhklEQVQoz5WS226CQBCGfSXvmz5lDw/QeNMbE6Ot9RBTLcYURS0JVVFYjlGEaBCwuuxuJ5KYNlFs/yxkd2Y+5md3M+y8KGWEpuRZ5iQFT7yz6FcHBtkvjsE/wJTAC68f+fL1a/4K++Vj8AJMKSUEw2Qzzz3cZHO32cgrwpKQ+AJMD0oc4nAQLe62zj0OpR9JmtY5iiLf3wRhEARREtnv96vVar1ex3Gc1hnS7TZXrz43G81K+WWz8WFUq5VSqVQoFFqt1m63Szz8gpO1bZlN7v3TZHZgcb03HemKqozH46Sm3+8bhpECW7wwdH3WcmtFoeCYDtKQJEkYY0KIIAiWZZ2FTcMYjkbMsVm3J2saUlVd13medxxnuVxyHGfb9nnYNAfD4eHv8USeIIQA7na7rut6ngdwWmfdMMejj6cGW3hMQ7KKkKZpoiiGYbjdbsFCGjyfz2u1qijOZFmt12vqwXY+n+8cBBMoOAEfPwHOkTpVlRkIThi2SlGU6XQqyzJs9YVL8i99A7FmT6k3BE3wAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"js_engine\"\n        title=\"js_engine\"\n        src=\"/static/44b6caf27337a5f2d63eee2a214696c3/2bef9/js_engine.png\"\n        srcset=\"/static/44b6caf27337a5f2d63eee2a214696c3/5a46d/js_engine.png 300w,\n/static/44b6caf27337a5f2d63eee2a214696c3/0a47e/js_engine.png 600w,\n/static/44b6caf27337a5f2d63eee2a214696c3/2bef9/js_engine.png 1024w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>    </p>\n<p>JS Engine의 개괄적인 이미지인데, 크게 두 가지의 구성요소가 존재한다.</p>\n<ul>\n<li>Memory Heap : 메모리 할당이 할당이 일어나는 곳</li>\n<li>Call Stack : 코드가 실행됨에 따라 스택 프레임이 쌓이는 곳</li>\n</ul>\n<p>다음은 JS Runtime이다. JS Runtime의 개괄적 이미지는 다음과 같다.    </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAAClklEQVQ4y5VTPZPSUBTN7/AnWfgH1NHKxnFmLSxdLbRxLWzWytHSytLGHcJCkg2BECCB4OLirKPLRwgQWD4ChHd89xGy+FX4Zu7kvZvkvHPuPVfCfyzGWLJfrxm2R3puzgzSfD5Ht9uF53lx+Ojy8LzeTs5DGIYJ6BVwxBOLzTNekq7ryOVyqFarqFRs2BUTbjXPn0VxdhwHhUIB+Xw+ZrYmWLS7azhugILVQu3zCF+/RRhfriHRx4vFIrlh4b9B07yLsP9+R95agG7l0Xr6cogbdzzcfuDj5v0ert/qQNbmG8DxeJz8fGbt4fDZNXyx9mOwCNPpFMViEb7vo1Qu8xK18OFjiCcHA7x4HeCAx/NXAZz6AhJJmUwmCWAYZDDpvMVyYlzleP1M0xT75XJF1+Dw3Rj3HvnYe9zHw/2+2BtWCIlupqa0Ln7g/PwcwWgmfpzOlqjX62g0GhgOh4LhrmSzEuIoM0Oay6T4xPcX7dVGsiynoeoW7LINRclyiZe8UTpqNReu6yKdTsOyrL90+c8laZoKOaPgrAvkAh0p4wi+1+dgteSjbDa70xSW+DCKfg3hQ01VoVN9Wt8xa5RRdB0O2BOMOp0O2u02MWSxZMZiRPYXmgJQ5YC5vIGRz2s3i+BwP/Z6PZRKJWFoqi9J5gwFRhRFCdhyucRqtRKxxZcUVYNZ0KCZEYa82Y5T4iCeaAIBE2gqlWKGYdCZccaMAIgQvScVFFunSDQlVCO3ZqNWdUCTQ+N4cnKCeIqYLMuMGDebTWbbtgDkDmCnp6ds6wSeFz6VqFaKovBQkclkxIiVuXnpouPjY5HjZSEgMjgbjUaMZHMrMYrBYIAgCAQYEZForMi4VA8K2tMLGkdiss391oR/+uYnfXBN3cXAJIcAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"js_runtime\"\n        title=\"js_runtime\"\n        src=\"/static/140f4d1b1341ebebf5a08daa184b6545/2bef9/js_runtime.png\"\n        srcset=\"/static/140f4d1b1341ebebf5a08daa184b6545/5a46d/js_runtime.png 300w,\n/static/140f4d1b1341ebebf5a08daa184b6545/0a47e/js_runtime.png 600w,\n/static/140f4d1b1341ebebf5a08daa184b6545/2bef9/js_runtime.png 1024w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span>    </p>\n<p>우리가 여기서 눈여겨봐야하는 특징은, JS Engine의 그림이 JS Runtime 내부에 존재한다는 것이다. 이게 무엇을 의미할까?    </p>\n<p><em>Runtime</em>을 인터넷에 치면 다음과 같은 내용이 나온다.</p>\n<blockquote>\n<p>런타임은 컴퓨터 과학에서 컴퓨터 프로그램이 실행되고 있는 동안의 환경을 말한다.       </p>\n</blockquote>\n<p>그렇다. <strong>JS Runtime</strong>은, <strong>JS</strong>를 돌리는 <strong>환경</strong>을 의미한다. 그렇기 때문에, V8이라는 engine이 runtime의 내부 모식도에 보이는 것이다.    </p>\n<p>이런 런타임은 종류에 따라 각기 다른 구조를 보여주기도 하며, 다른 API를 제공해주기도 한다. </p>\n<p>결론적으로 Node.js와 Chrome은 동일한 V8 엔진을 사용하지만, 각기 다른 runtime을 가지고 있다는것이 이 이유이다. (출처: <a href=\"https://geonlee.tistory.com/91\">자바스크립트 엔진(JavaScript Engine)과 자바스크립트 런타임(Javascript Runtime)의 차이</a>)</p>\n<hr>\n<h3 id=\"call-stack\" style=\"position:relative;\"><a href=\"#call-stack\" aria-label=\"call stack permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Call stack</h3>\n<p>그렇다면 이제 본격적으로 single-thread인 javascript가 어떻게 여러 개의 작업을 처리하는지 알아보자.    </p>\n<p>그러기 위해서는 <em>Call stack</em> 부터 알아야한다. 위에서 간단한 설명을 한 것처럼, Call stack은 코드가 한 줄씩 실행되면서 그에 따른 <em>스택 프레임(stack frame)</em> 이 쌓이는 곳이다.    </p>\n<p>스택 프레임이 무엇이냐면 간단하게 생각하면 다음과 같다.</p>\n<blockquote>\n<p>함수 foo, boo, bar가 존재한다고 하자. 함수 foo안에서 boo를 호출하고, boo안에서는 bar를 호출한다. 내가 만약 함수 foo를 실행하면 어떻게 될까?     </p>\n</blockquote>\n<p>물론 우리는 bar -> boo -> foo의 순서로 함수가 실행됨을 쉽게 알 수 있다. 하지만 함수가 100개라면? 그리고 그게 서로 얽히고 얽혀있다면?    </p>\n<p>이럴때 사용되는 개념이 스택 프레임이다. 함수가 무엇을 호출하는지, 어디로 되돌아가야 하는지를 명시하는 일종의 이정표인 셈이다.    </p>\n<p>위의 개념을 이용해서, 컴퓨터는 함수를 실행하면 먼저 스택 프레임을 저장하고 다른 함수로 이동하여 순차적으로 실행되는 로직을 가지고 있는 셈이다.    </p>\n<p>다음은 예제이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function multiply(x, y) {\n    return x * y;\n}\nfunction printSquare(x) {\n    var s = multiply(x, x);\n    console.log(s);\n}\nprintSquare(5);</code></pre></div>\n<br />\n위의 코드의 call stack은 아래와 같이 쌓임을 알아두자.\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPklEQVQoz6WT3aqCUBBG9/s/iUKCeCG9h4ngjRdpaf4dtdLUOmcdBzYS0k0D0drj981Ms039fhGKz2sJnRJ+Pp95nmdZNs/zm0az+lD4reh252EY+r6X8+PxuN/vwsMSwiQ13243ZP9mvpjtdDpdr1fhJElgpGmans9nbJRGwBHgGMfx5XJBrJqmGceRMj9LCJOsqmqaJsau6xoG2AKARgYEVNu2iDh3XYdH1gPzDDWMgLysgCSPYCzk382a0VEIA0nptm1ej6q7lWUpq8ZAXi6PpEyx0RmdbBLgp8qGATTbnaWhlCdc1zVN0/d93hDHcQzDCIIATb1EURRchJipojDs93vLsjzPowS82+0OhwNmCpEPw/B4PFLItu0oimjIhcmYihrMOS6xZmLNa4HcNkf11R/jtQr9Pn9m/eb/AQMAXrdGXXbrAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"js_callstack\"\n        title=\"js_callstack\"\n        src=\"/static/d7c88d785b19da93aae77dfff983c660/2bef9/js_callstack.png\"\n        srcset=\"/static/d7c88d785b19da93aae77dfff983c660/5a46d/js_callstack.png 300w,\n/static/d7c88d785b19da93aae77dfff983c660/0a47e/js_callstack.png 600w,\n/static/d7c88d785b19da93aae77dfff983c660/2bef9/js_callstack.png 1024w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>여기서 javascript의 call stack의 문제점이 나오게 된다. single-thread 기반의 javscript이므로, 한 번에 한 개의 작업밖에 못하므로 만약 다음과 같은 코드를 실행시키면 다른 작업들이 끼어들지 못한다.    </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">function foo() {\n    foo();\n}\nfoo();</code></pre></div>\n<br />\n<p>이는 다음과 같은 call stack을 생성시킬것이다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1024px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAIAAABr+ngCAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQ0lEQVQoz6WS2Y6CQBBF+f/vMPIginEL+MB38GTY3GIUhbCDzolFGHVmEs3UA7ldXaf7VjXK7ZO43qNbKi+pTjdNczgc9vt9Xdd/naW8f1VVVefz+XK5IL7hPM+zLJN1do9OF0XRHYQOgsDzPOpbmBTeNptNkiRkd7vddrtFQ67Xa3SaplLKlqqqvV7P930xpWCjLEsWWDqdTrQqOgxDtlkiBOZOXdcHg8FqtWrhKIqkhziOYaRDkhwqFSIeYcdxPoZpeDqdwj/BYpui4/EosLQgDLZ5LfKu647HY03Tfr+ZOubHWWjuMU1zuVwyts428HA4fIJhZELMczabyUhgmG2/35dSgUej0VPPMJZl0Yxt2/xShmFMJhNgHmmxWMzncxiBeSG8kMR/C+NZrPJF1/dAlA8h8M+McvtHKNc34uVX7zJfPFFRsvAS20sAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"js_callstack_maximum\"\n        title=\"js_callstack_maximum\"\n        src=\"/static/4ac50c10ab7211c7f28faecde9c5a1cd/2bef9/js_callstack_maximum.png\"\n        srcset=\"/static/4ac50c10ab7211c7f28faecde9c5a1cd/5a46d/js_callstack_maximum.png 300w,\n/static/4ac50c10ab7211c7f28faecde9c5a1cd/0a47e/js_callstack_maximum.png 600w,\n/static/4ac50c10ab7211c7f28faecde9c5a1cd/2bef9/js_callstack_maximum.png 1024w\"\n        sizes=\"(max-width: 1024px) 100vw, 1024px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>위와 같이, single-thread에서 코드를 돌리는건 매우 multi-thread와 같은 환경에서 나오는 <em>deadlock</em> 과같은 치명적인 문제가 생기지는 않지만 한계가 명확하다.    </p>\n<p>그럼 여기서 만약, 실행시간이 오~래 걸리는 코드를 실행시키면 어떻게 될까?    </p>\n<hr>\n<h3 id=\"event-loop--callback-queue-concurrency\" style=\"position:relative;\"><a href=\"#event-loop--callback-queue-concurrency\" aria-label=\"event loop  callback queue concurrency permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Event loop &#x26; Callback Queue, Concurrency</h3>\n<p>위에서 물어봤던 질문은 이곳에서 아주 큰 위험이 될 것이다. 생각을 다음과 같이 해보자.    </p>\n<blockquote>\n<p><em>Button을 누르면 call stack에 쌓이고 나서 약 10초뒤에 작업이 끝나는 stack frame이 존재하는데, 해당 frame이 끝나고 나서 button에다가 focus를 해야한다면?</em></p>\n</blockquote>\n<p>어떻게 될까? 정말 끔찍한 시간이 될 거다. 웹 사이트는 약 10초 동안의 시간동안 아~무일도 안할거다. Button이 pressed된 상태에서 10초동안 기다렸다가 10초뒤에야 겨우 unpressed되고 focused될 것이다.    </p>\n<p>만약 우리가 쓰는 네이버나 구글같은 사이트가 이렇게 작동한다고 해보자. 어떨까? 최악의 UX를 가져다 줄 것이다. 이게 모두 한 번에 한 작업, 즉 동기적으로 작동하기 때문이다.    </p>\n<p>하지만 우리가 쓰는 웹 사이트가 위와 같이 작동하는가? 우리의 웹 사이트는 그렇게 작동하지 않는다. 우리는 유튜브를 보면서, 동시에 유튜브에 댓글을 달고, 동시에 유튜브의 영상 목록을 스크롤링한다. 위의 방법과 같게 작동한다면 꿈도 못꿀 이야기이다.    </p>\n<p>이는 모두 <em>asynchronous</em>, <strong>비동기적</strong>으로 작동하기 떄문이다. 작업을 진행할때, 한 작업이 끝나기를 기다리지 않고 그 시간동안 다른 작업들을 진행하는 것이다.    </p>\n<p>그렇다면 여기서 질문. Single-thread인 자바스크립트는 도대체 어떻게 <strong>비동기적으로</strong> 작업하는것일까? Thread가 한 개이니, 한 작업씩만 처리할 수 밖에 없을텐데..    </p>\n<p>물론 한 번에 한 작업씩 처리하는 것도 맞고, single-threaded인 것도 맞다. 중요한건 <strong>Event loop</strong>과 <strong>Callback Queue</strong>가 존재한다는 것이다.    </p>\n<p><strong>Callback Queue</strong>는 이름에서 유추할 수 있듯이, 비동기적으로 실행된 <em>콜백(Callback)</em>함수들이 순서대로 쌓이는 영역이다.    </p>\n<p><strong>Event Loop</strong>은 Call Stack을 주기적으로 확인하여, 만약 비어있다면 Callback Queue에 존재하는 작업을 <em>FIFO</em>로 넣어준다.    </p>\n<p>이러한 구조때문에 <em>비동기적</em> 이며 <em>single-thread</em>인 JS가 여러 개의 작업을 동시(Concurrency)에 할 수 있는것이다! 다음의 예제를 보면 이해가 갈 것이다.    </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">console.log('Hi')\n\nsetTimeout(function callback(){\n    console.log('There')\n}, 5000)\n\nconsole.log('End')\n\n// Result\nHi\nEnd\nThere</code></pre></div>\n<p>JS를 처음 접하는 분들은 위와 같은 결과값이 이해가 가지 않을 것이다. 하지만 다음의 설명을 먼저 보자. 실행 순서는 다음과 같게 흘러간다.</p>\n<ol>\n<li>코드를 읽으면서 console.log(‘HI’)을 만나 Call stack에 집어넣는다.</li>\n<li>Call stack에 있는 작업을 실행 // ‘hi’</li>\n<li>코드를 읽으면서 setTimeout 함수를 만나서, Web API의 ‘timer’를 호출하여 5초를 기다리게 함.</li>\n<li>그 동안에 JS는 아래의 console.log(‘End’)를 만나서 Call stack에 집어넣고 실행 // ‘End’</li>\n<li>timer의 5초가 지났기 때문에, 콜백 함수인 ‘callback()’ 함수를 Callback Queue에 집어넣음</li>\n<li>Call stack이 비었기 떄문에, event loop은 Call Queue를 보고있었는데 갑자기 ‘callback()‘함수가 들어와서 해당 함수를 Call stack에 적재!</li>\n<li>Call stack에 존재하는 ‘callback()’ 함수 실행! // ‘There’</li>\n</ol>\n<p>위와 같은 순서로 JS는 실행된다. 어떤가? 이제야 왜 single-thread인 JS가 동시에 여러 개의 작업을 처리할 수 있는지 알겠는가?    </p>\n<p>혹시 글로 되어있어서 읽기가 힘들다면, <a href=\"http://latentflip.com/loupe/?code=Y29uc29sZS5sb2coIkhpISIpOwoKJC5vbignYnV0dG9uJywgJ2NsaWNrJywgZnVuY3Rpb24gb25DbGljaygpIHsKICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gdGltZXIoKSB7CiAgICAgICAgY29uc29sZS5sb2coJ1lvdSBjbGlja2VkIHRoZSBidXR0b24hJyk7ICAgIAogICAgfSwgMjAwMCk7Cn0pOwoKCnNldFRpbWVvdXQoZnVuY3Rpb24gdGltZW91dCgpIHsKICAgIGNvbnNvbGUubG9nKCJDbGljayB0aGUgYnV0dG9uISIpOwp9LCA1MDAwKTsKCmNvbnNvbGUubG9nKCJXZWxjb21lIHRvIGxvdXBlLiIpOw%3D%3D!!!PGJ1dHRvbj5DbGljayBtZSE8L2J1dHRvbj4%3D\">Loupe</a>라는 사이트에 들어가서 위의 코드를 실행시켜보자. Loupe라는 사이트는 JS의 환경에서 실행되는 프로세스를 그림으로 보여주는 사이트이다.    </p>\n<h3 id=\"wrap-up\" style=\"position:relative;\"><a href=\"#wrap-up\" aria-label=\"wrap up permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wrap-up</h3>\n<p>지금까지 JS가 어떻게 여러 개의 작업을 실행할 수 있는지에 대해서 알아보았다.    </p>\n<p>결론적으로 JS가 single-thread임에도 불구하고 여러 작업을 진행할 수 있는 이유는 JS가 가진 특유의 <strong>구조</strong>떄문이라는 것을 알게 되었다.    </p>\n<p>해당 내용은 생각보다 어렵기도 하고, 중요한 내용이기도 하니 자주 반복해서 글을 읽어 지식을 습득하려고 노력해보려고 한다 :)</p>\n<hr>\n<h3 id=\"참고한-사이트들\" style=\"position:relative;\"><a href=\"#%EC%B0%B8%EA%B3%A0%ED%95%9C-%EC%82%AC%EC%9D%B4%ED%8A%B8%EB%93%A4\" aria-label=\"참고한 사이트들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>참고한 사이트들</h3>\n<p><a href=\"https://new93helloworld.tistory.com/358\">자바스크립트 호출 스택(Call Stack) 이해하기</a>        </p>\n<p><a href=\"https://medium.com/@gaurav.pandvia/understanding-javascript-function-executions-tasks-event-loop-call-stack-more-part-1-5683dea1f5ec\">Understanding Javascript Function Executions — Call Stack, Event Loop , Tasks &#x26; more</a>    </p>\n<p><a href=\"https://velog.io/@thms200/Event-Loop-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%A3%A8%ED%94%84\">Event Loop (이벤트 루프)</a>    </p>","frontmatter":{"title":"Single thread인 JS가 어떻게 여러 개의 작업을 처리할까?","date":"June 13, 2020"}}},"pageContext":{"slug":"/development/what-is-call-stack-and-event-loop/","previous":{"fields":{"slug":"/development/es6-syntax/"},"frontmatter":{"title":"ES6가 무엇일까?"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}